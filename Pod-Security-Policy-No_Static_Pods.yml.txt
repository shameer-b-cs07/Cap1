apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: no-static-pods
spec:
  privileged: false
  allowPrivilegeEscalation: false
  hostIPC: false
  hostNetwork: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'RunAsAny'
  volumes:
    - '*'
  allowedHostPaths:
    - pathPrefix: '/etc/kubernetes/manifests'
      readOnly: true
  forbiddenSysctls:
    - '*'
  hostPorts:
    - min: 1
      max: 65535
  fsGroup:
    rule: 'RunAsAny'
  requiredDropCapabilities:
    - 'ALL'
  allowedCapabilities:
    - 'AUDIT_WRITE'
    - 'KILL'
    - 'NET_ADMIN'
    - 'NET_RAW'
    - 'SETUID'
    - 'SETGID'
    - 'SYS_CHROOT'
    - 'MKNOD'
    - 'SYS_RESOURCE'
  namespaceSelector:
    matchLabels:
      name: kube-system
  # Pod Security Policy is not namespaced, so we need to use a ClusterRole
  # and a ClusterRoleBinding to grant access to it
  # Replace with the name of your desired ClusterRole and ClusterRoleBinding
  # if using a different configuration
  # or if your Kubernetes cluster uses RBAC authorization.
  # See: https://kubernetes.io/docs/reference/access-authn-authz/rbac/
  # See: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
  # for more details on Pod Security Policies and how to use them.
  # ---
  # kind: ClusterRole
  # apiVersion: rbac.authorization.k8s.io/v1
  # metadata:
  #   name: no-static-pods
  # rules:
  #   - apiGroups: [ "policy" ]
  #     resources: [ "podsecuritypolicies" ]
  #     verbs: [ "use" ]
  #     resourceNames: [ "no-static-pods" ]
  # ---
  # kind: ClusterRoleBinding
  # apiVersion: rbac.authorization.k8s.io/v1
  # metadata:
  #   name: no-static-pods
  # subjects:
  #   - kind: Group
  #     name: system:serviceaccounts
  #     apiGroup: rbac.authorization.k8s.io
  # roleRef:
  #   kind: ClusterRole
  #   name: no-static-pods
  #   apiGroup: rbac.authorization.k8s.io
